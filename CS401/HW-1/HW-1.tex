\documentclass[11pt]{article}
\usepackage{minted}
\usepackage{amsfonts, amssymb, amsmath, float}
\usepackage{enumerate, esint, nicefrac, algorithm2e}
\title{CS 401 :: Homework 1}
\author{Ryan Magdaleno}
\parindent 0px

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Problem 1.} Ordering functions by their asymptotic dominance. \\
Order $f_1, f_2,...,$ such that $i\ge1,$ we have $f_i(n)=O(f_i+1(n)).$

\vspace{5px}\textbf{Solution ::}
$$ \log(\log(n)) < \log(n) < 1000\cdot n < n\cdot\log(n) < n^2 < n^{\log n} < 2^n 
< 2^{2^n}$$
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Problem 2.} 
\begin{enumerate}[(a)]
\item 
Prove or disprove that $2^{n+1}=O(2^n)$.

\vspace{5px}\textbf{Solution ::} \\
I will use the following proof: \\
By definition of the limit, there exists $n_0$ such that for all $n \ge n_0$:
$$\frac{1}{2}c \le \frac{f(n)}{g(n)} \le 2c$$ 
If we let $c=1$, then:
\begin{align}
    \frac{1}{2} &\le \frac{2^{n+1}}{2^n} \le \,2 \\
    \frac{1}{2} &\le 2 \le \,2
\end{align}
This inequality holds for all $n \ge n_0$. \\
$\therefore 2^{n + 1} = O(2^n)$, given $n_0 = 1$ \\
\line(1,0){339px}
\item 
Prove or disprove that $2^{2n}=O(2^n)$.

\vspace{5px}\textbf{Solution ::} \\
I will use the following proof: \\
$T(n)$ is $O(f(n))$ if:
$$\limsup_{n\rightarrow\infty}\frac{T(n)}{f(n)}<\infty$$
Let's simply the expression (3) and take the limit (4):
\begin{align}
    \limsup_{n\rightarrow\infty} \frac{2^{2n}}{2^n} &= \limsup_{n\rightarrow\infty}
    2^n \\
    &= \infty
\end{align}
$\therefore$ Because the limit is $\infty$, this means $2^{2n} \neq O(2n)$
\end{enumerate}
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Problem 3.} Give the asymptotic running time of the following algorithm 
in $\Theta$ notation. Justify both the upper and the lower bound.

\vspace{10px}
\begin{algorithm}
\textsc{func1$(n)$}\;
$s\gets 0$\;
$i\gets 5$\;
\While{$(i<n^2+7)$}
{
    \For{$j\gets i$ \textbf{to} $i^3\log i$}
    {
        $s\gets s+1$\;
    }
    $i\gets i\times 4$\;
}
\end{algorithm}
\textbf{Solution ::}

\textbf{Upper Bound ::}
\begin{enumerate}[1.]
\item
The outer loop runs until $i \ge n^2 + 7$, $i$ will be multiplied by 4 each iteration.
This indicates in the worst case that the outer loop contributes 
$O\left(\frac{\log_4(n^2 + 7)}{5}\right)$ to 
the overall complexity.

\item
The inner loop runs $i^3\log(i)$ iterations for each outer loop iteration. We can
relate the inner loop to the outer loop by looking at the highest possible values of i
based on the outer iteration. The max number of iterations of the inner loop can be 
approximated via the geometric sum of $i^3\cdot\log(i)$ from $i = 0$ to $i = \frac
{\log_4(n^2 + 7)}{5}$ for the function $i^3\cdot\log(i)$. The sum approximated for
a maximized $i$ is $n^2$ therefore the $i^3$ term contributes $(n^2)^3 = n^6$. The
$\log(i)$ therefore is $\log(n^2)$. In the worst case this indicates that the inner loop
contributes $O(n^6\log(n^2))$ to the overall complexity.

\item 
All together the upper bound of this algorithm is:
$$O\left(\frac{\log_4\left(n^2+7\right)}{5}\cdot
\left(n^6\log\left(n^2\right)\right)\right)$$
or more simplfied:
$$O\left(\log_4\left(n^2\right)\cdot\left(n^6\log\left(n^2\right)\right)\right)$$
\end{enumerate}

\pagebreak
\textbf{Lower Bound ::}

\begin{enumerate}[1.]
\item
For the lower bound, the best case for this algorithm would be when $n = 0$ making
the outer loop iterate a single time.

\item 
The inner loop would then iterate the constant $i$ to $i^3\log(i)$

\item
This indicates that in the best-case scenario, the lower bound is:
$$\Omega\left(1 \cdot \left(5^3\log(5)\right)\right)$$
and since $i=5$ is a constant this can be simplfied to:
$$\Omega(1)$$
\end{enumerate}
\textbf{Big Theta Time ::}
\begin{enumerate}[1.]
\item 
The dominant terms from both functions combines to give us the following theta
complexity:
$$\Theta\left(n^6\cdot\log_4\left(n^2+7\right)\right)$$
or simply:
$$\Theta\left(n^6\cdot\log_4\left(n^2\right)\right)$$
\end{enumerate}
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Problem 4.} 
\begin{enumerate}[(a)]
\item 
You are given a set of $n$ items of sizes $a_1,...,a_n\in\mathbb{N},$
and a bin size $\it{B}\in\mathbb{N}$. Your goal is to find a maximum cardinality
subset of items that all fit inside the bin. That is, you want to find a set of
distinct indices $\it{I}=\{i_1,...,i_k\}\subseteq\{\text{1},...,n\},$ such that
$$a_{i_1}+...+a_{i_k}\le\it{B,}$$
maximizing $k$. Design a greedy algorithm. Running time of your algorithm should
be polynomial in $n$.

\vspace{5px}\textbf{Solution ::}

Given some way to keep track of an item's original index even after moving it, 
my algorithm would follow like so:
\begin{enumerate}[1.]
    \item Have some sum variable $s$ initialized to 0.
    \item Sort the set that contains the items $a_1,...,a_n$ in ascending order.
    \item Add each $a_i$ value to $s$ and respective index to $I$ if $s + a_i \le B$.
    \item Break summation early if (3) condition was not met.
    \item Return the resultant $I$ set.
\end{enumerate}

\textbf{Runtime Analysis ::}
\begin{enumerate}[1.]
\item 
If we anaylyze the code in the subsequent pages, there's a single sorting step which
indicates an $O(n \log n)$ time, where $n$ is the number of items.
\textbf{Dominant step.}

\item 
The for loop in the worst case will iterate fully when $\textsc{itemSizeSum}$ 
never becomes greater than $B$, indicating an $O(n)$ run time.

\item 
The algorithmâ€™s time complexity is $O(n\log n) + O(n)$ which
simplfies to $O(n\log n)$. Therefore this algorithm indeed runs in time
polynomial in $n$.
\end{enumerate}

I've written C++23 code that follows this algorithm below. The code below can be
compiled if you invoke with my provided compilation command. Please have a look at the
function \textsc{ProblemFour} for my algorithm implementation.
\pagebreak

\begin{minted}{c}
// g++ -std=c++23 -O2 -Wall $(NAME).cpp -o $(NAME).exe
#include <algorithm>
#include <iostream>
#include <vector>

struct Item { int size, index; };
bool compareItems(Item i1, Item i2) { return (i1.size < i2.size); }

std::vector<int> ProblemFour(std::vector<Item> items,
                             const int& B)
{
    std::vector<int> I;
    int itemSizeSum = 0;  // 1) s variable = 0.

    // 2) Sort items in ascending order:
    std::sort(items.begin(), items.end(), compareItems);

    // 3) Collect front items until s + a_i > B:
    for (const Item& i : items) {
        itemSizeSum += i.size;
        if (itemSizeSum > B) { break; } // 4) Break summation early.
        I.push_back(i.index);
    }
    return I; // 5) Return resultant I set.
}
\end{minted}
\pagebreak

\begin{minted}{c}
int main()
{
    std::vector<int> numsToAdd = {4, 10, 32, 2, 44, 132, 60, 23, 1};
    int n = (int)numsToAdd.size();
    int B = 100;

    std::vector<Item> items;
    items.reserve(n);

    for (int i = 0; i < n; ++i) {
        items.push_back({numsToAdd[i], i});
    }
    std::vector<int> I = ProblemFour(items, B);
    std::cout << "Set of n items: ";
    for (const int& size : numsToAdd) {
        std::cout << size << ' ';
    }

    std::cout << "\nReturned I set: ";
    for (const int& index : I) {
        std::cout << index << ' ';
    }
    return 0;
}
\end{minted}
\pagebreak

\item
Suppose that instead of maximizing $k$, we want to maximize the total size of the
items in the bin; that is, we want to maximize the quantity
$$\text{size}(I)=a_{i_1}+...+a_{i_k}.$$
Show that your greedy algorithm does not work in this case.

\vspace{5px}\textbf{Solution ::}

To show that my algorithm doesn't work with part b, we can show a counter example.

$A = \{1,\, 2,\, 99\},\,B = 100,\, n = 3$

My algorithm would sort the $A$ set and sum the values up until:

size$(I) = 3$

In this case my algorithm would terminate on size$(I) = 3$ where,

size$(I) = 1 + 2$ and $I = \{1, 2\}$ (1-based indices).

However the most optimal size$(I)$ would be size$(I) = 100$ where,

size$(I) = 1 + 99$ and $I = \{1, 3\}$.

$\therefore$ My algorithm does not work in certain cases if we are trying to maximize
the quantity:
$$\text{size}(I)=a_{i_1}+...+a_{i_k}.$$

\end{enumerate}
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Problem 5.} A group of $n$ people are lying on the beach. The beach is 
represented by the real line $\mathbb{R}$ and the location of the $i$-th person is some 
integer $x_i\in\mathbb{Z}$. Your task is to prevent people from getting sunburned by 
covering them with umbrellas. Each umbrella corresponds to a closed interval 
$I = [a, a + L]$ of length $L\in\mathbb{N}$, and the $i$-th person is covered by that 
umbrella if $x_i\in I$. Design a greedy algorithm for covering all people with the
minimum number of umbrellas. The input consists of the integers $x_1, . . . , x_n$, 
and $L$. The output of your algorithm should be the positions of umbrellas.

\vspace{5px}
Prove that your algorithm is correct and that it runs in time polynomial in $n$.

\vspace{5px}\textbf{Solution ::}

Assuming all person indices are unique and $L$ and $n$ can't be negative
my algorithm would be like so:
\begin{enumerate}[1.]
    \item Create some container $U$ for the umbrella positions.
    \item Sort people indices in ascending order.
    \item Place umbrella such that the first uncovered person is in the leftmost pos.
    \item Count how many people got covered and add the current umbrella index to $U$.
    \item Repeat steps $3-4$ until total covered people $== n$.
    \item Return resultant $U$ container.
\end{enumerate}

\textbf{Correctness ::}
\begin{enumerate}[1.]
\item 
This algorithm is greedy because it always picks an umbrella that covers the leftmost
uncovered person.

\item 
This algorithm will terminate because at each iteration, the algorithm selects an
umbrella position that covers the leftmost uncovered person.
By doing so, this algorithm ensures that all people will eventually be covered
by an umbrella and will do so until the number of covered people is equal to $n$.

\item 
This algorithm is optimal because of the leftmost position selection, this will minimize
the number of umbrellas required to cover subsequent \\people.
\end{enumerate}
\pagebreak

\textbf{Runtime Analysis ::}

\begin{enumerate}
\item
If we anaylyze the code in the subsequent pages, there's a single sorting step which
indicates an $O(n \log n)$ time, where $n$ is the number of people.
\textbf{Dominant step.}

\item 
Placing people on the beach vector always takes $O(n)$ time.

\item 
The main while loop iterates until every person is covered, in the worst case, each
person would need their own loop iteration/umbrella. There's an inner loop that always
runs $O(L + 1)$ times, where L is the given constant $L$. Therefore, the while loop runs
$O(n \cdot (L+1)) = O(n)$ times.

\item 
The algorithm's time complexity is $O(n\log n) + O(n) + O(n)$ which simplfies to
$O(n \log n)$. Therefore this algorithm indeed runs in time polynomial in $n$.

\vspace{5px}I've written C++23 code that follows this algorithm below. The code below
can be compiled if you invoke with my provided compilation command. Please have a look
at the function \textsc{ProblemFive} for my algorithm implementation.
\pagebreak

\end{enumerate}
\vspace{90px}

\begin{minted}{c}
// g++ -std=c++23 -O2 -Wall $(NAME).cpp -o $(NAME).exe
#include <algorithm>
#include <iostream>
#include <vector>
struct BeachPoint { bool umbrella = false, covered = false, person = false; };
void printBeach(const std::vector<BeachPoint>& beach)
{
    std::cout << "\nU C P\n";
    for (const auto& bp : beach) {
        std::cout << bp.umbrella << ' '
                  << bp.covered  << ' '
                  << bp.person   << '\n';
    }
}

\end{minted}

More below:
\pagebreak

\begin{minted}{c}
std::vector<int> ProblemFive(std::vector<int>& personIndices,
                             const int& L,
                             const int& N)
{
    // Bad value check:
    if (L < 0 || N < 0) { return {}; }

    // Sort personIndices in ascending order:
    std::sort(personIndices.begin(), personIndices.end());

    // Set up and place people on beach:
    std::vector<BeachPoint> beach(personIndices[N - 1] + L + 1);  // Ensure space.
    std::vector<int> umbrellaIndices;                             // Returned vector.
    for (const int& personIndex : personIndices) {
        beach[personIndex].person = true;
    }

    int covered = 0, personPos, umbrellaPos;
    while (covered < N) {
        personPos = personIndices[covered];  // Get first uncovered person's index.
        umbrellaPos = personPos + (L/2);     // Calc Umbrella position like step 2.
        umbrellaIndices.push_back(umbrellaPos);

        // Place umbrella on beach and count how many got covered:
        beach[umbrellaPos].umbrella = true;
        for (int i = personPos; i <= personPos + L; i++) {
            if (beach[i].person) { covered++; }
            beach[i].covered = true;
        }
    }
    printBeach(beach);
    return umbrellaIndices;
}
\end{minted}
\pagebreak

\begin{minted}{c}
int main()
{
    std::vector<int> inputIndices = {1, 3, 5};
    const int L = 2, N = (int)inputIndices.size();  // 3 people to cover.

    std::vector<int> outputIndices = ProblemFive(inputIndices, L, N);

    // Print umbrella positions:
    std::cout << "\nUmbrellas: " << outputIndices.size() << '\n';
    std::cout << "Umbrella indices (0-based):\n";
    for (const int& umbrellaIndex : outputIndices) {
        std::cout << umbrellaIndex << ' ';
    }
    return 0;
}
\end{minted}
\end{document}